<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Unspoken Hearts üíå</title>
  <link href="https://fonts.googleapis.com/css2?family=Pacifico&family=Poppins:wght@300;400;600&family=Caveat&family=Roboto+Mono&family=Indie+Flower&family=Shadows+Into+Light&display=swap" rel="stylesheet" />
  <style>
    /* Same styles as before - minimalist & cutesie with dark mode */
    :root {
      --bg-color: #fff5f8;
      --card-bg: #fff;
      --text-color: #444;
      --border-color: #ddd;
    }
    body.dark {
      --bg-color: #1e1e1e;
      --card-bg: #2b2b2b;
      --text-color: #eee;
      --border-color: #555;
    }
    body {
      font-family: 'Poppins', sans-serif;
      background: var(--bg-color);
      color: var(--text-color);
      padding: 20px;
      transition: background 0.3s ease, color 0.3s ease, font-family 0.3s ease;
    }
    h1 {
      font-family: 'Pacifico', cursive;
      text-align: center;
      color: #ff5e94;
      margin-bottom: 20px;
      animation: fadeIn 1.5s ease;
    }
    @keyframes fadeIn {
      from {opacity: 0; transform: translateY(-10px);}
      to {opacity: 1; transform: translateY(0);}
    }
    #passwordSection,
    #diarySection {
      max-width: 650px;
      margin: auto;
      background: var(--card-bg);
      border-radius: 20px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
      padding: 20px;
      transition: all 0.3s ease;
      animation: fadeIn 1s ease;
    }
    textarea,
    input[type='text'],
    input[type='password'],
    select {
      width: 100%;
      padding: 10px;
      margin: 8px 0;
      border-radius: 12px;
      border: 1px solid var(--border-color);
      font-family: inherit;
      background: var(--card-bg);
      color: var(--text-color);
      resize: vertical;
    }
    button {
      background: #ff5e94;
      color: #fff;
      border: none;
      border-radius: 12px;
      padding: 10px 16px;
      margin-top: 8px;
      cursor: pointer;
      font-weight: bold;
      transition: background 0.3s ease, transform 0.2s;
    }
    button:hover {
      background: #e14c82;
      transform: scale(1.05);
    }
    .entry {
      border-radius: 15px;
      padding: 12px;
      margin: 12px 0;
      box-shadow: 0 0 6px rgba(0,0,0,0.1);
      background: var(--card-bg);
      position: relative;
      overflow: hidden;
      animation: fadeIn 0.8s ease;
    }
    .red { border-left: 6px solid #ff99aa; }
    .blue { border-left: 6px solid #99cfff; }
    img {
      max-width: 100%;
      border-radius: 10px;
      margin-top: 10px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.05);
    }
    .reply {
      margin-left: 15px;
      font-size: 0.85em;
      padding: 6px 10px;
      background: var(--card-bg);
      border-radius: 10px;
      margin-top: 6px;
      border: 1px dashed var(--border-color);
      animation: fadeIn 0.5s ease;
      position: relative;
    }
    .reply small {
      display: block;
      color: var(--text-color);
      margin-top: 4px;
    }
    .delete-reply {
      position: absolute;
      top: 4px;
      right: 8px;
      background: transparent;
      border: none;
      color: var(--text-color);
      cursor: pointer;
      font-weight: bold;
      font-size: 1.1em;
      line-height: 1;
      padding: 0;
    }
    #photoDump img {
      width: 70px;
      height: 70px;
      object-fit: cover;
      margin: 5px;
      border-radius: 8px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
      transition: transform 0.2s;
      cursor: pointer;
    }
    #photoDump img:hover {
      transform: scale(1.1);
    }
    #fontSelector {
      margin: 10px 0;
    }
    .dark-toggle {
      margin: 10px 0;
      cursor: pointer;
      font-weight: bold;
      color: #ff5e94;
      text-align: center;
      user-select: none;
    }
    @media (max-width: 700px) {
      #passwordSection,
      #diarySection {
        width: 90%;
      }
    }
  </style>
</head>
<body>
  <h1>Unspoken Hearts üíå</h1>
  <div class="dark-toggle" onclick="toggleDarkMode()">üåô Toggle Dark Mode</div>

  <div id="app">
    <div id="passwordSection">
      <input type="password" id="sharedPassword" placeholder="Enter shared password" />
      <button onclick="checkPassword()">Access Diary</button>
    </div>

    <div id="diarySection" style="display:none;">
      <div id="fontSelector">
        <label><strong>Choose Font:</strong></label>
        <select onchange="changeFont(this.value)">
          <option value="'Poppins', sans-serif">Poppins</option>
          <option value="'Caveat', cursive">Caveat (Handwriting)</option>
          <option value="'Roboto Mono', monospace">Roboto Mono (Typewriter)</option>
          <option value="'Indie Flower', cursive">Indie Flower</option>
          <option value="'Shadows Into Light', cursive">Shadows Into Light</option>
        </select>
      </div>

      <textarea id="entryText" placeholder="Write your thoughts..."></textarea>
      <input type="file" id="imageInput" accept="image/*" />
      <input type="text" id="entryAuthor" placeholder="Your name (Dave or Jeah)" />
      <select id="entryCategory">
        <option value="General">General</option>
        <option value="Memories">Memories</option>
        <option value="Love Notes">Love Notes</option>
        <option value="Random">Random</option>
      </select>
      <button onclick="addEntry()">Post Entry</button>

      <div>
        <button onclick="sendMood('happy')">üòä Happy</button>
        <button onclick="sendMood('sad')">üò¢ Sad</button>
        <button onclick="sendMood('love')">‚ù§Ô∏è Love</button>
      </div>

      <div>
        <label><strong>Filter by Category:</strong></label>
        <select id="filterCategory" onchange="loadEntries()">
          <option value="All">All</option>
          <option value="General">General</option>
          <option value="Memories">Memories</option>
          <option value="Love Notes">Love Notes</option>
          <option value="Random">Random</option>
        </select>

        <label><strong>Sort:</strong></label>
        <select id="sortOrder" onchange="loadEntries()">
          <option value="asc">Oldest First</option>
          <option value="desc" selected>Newest First</option>
        </select>

        <input type="text" id="searchKeyword" placeholder="Search text..." oninput="loadEntries()" style="margin-left:10px" />
      </div>

      <div id="entries"></div>

      <h3>üì∏ Photo Dump</h3>
      <div id="photoDump"></div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/emailjs-com@3/dist/email.min.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>
  <script>
    // Your Firebase config - replace with your actual config
    const firebaseConfig = {
      apiKey: "AIzaSyDtHj92IVoxoyz2EtMVaaHVKyPP7UHDpEU",
      authDomain: "unspoken-hearts-diary.firebaseapp.com",
      projectId: "unspoken-hearts-diary",
      storageBucket: "unspoken-hearts-diary.firebasestorage.app",
      messagingSenderId: "885095961873",
      appId: "1:885095961873:web:4b4c846cc2b28dbce928b0",
      measurementId: "G-2L9NESBKWN"
    };

    // Initialize Firebase
    firebase.initializeApp(firebaseConfig);
    const db = firebase.firestore();

    // EmailJS init
    emailjs.init("QuFveASS-r2Favhcs");

    const SHARED_PASSWORD = "usdiary2025"; // <--- Your password here

    // Dark mode persistence
    document.addEventListener("DOMContentLoaded", () => {
      if(localStorage.getItem("darkMode") === "true") {
        document.body.classList.add("dark");
      }
      const savedFont = localStorage.getItem("selectedFont");
      if(savedFont) {
        changeFont(savedFont);
        document.querySelector("#fontSelector select").value = savedFont;
      }
    });

    function toggleDarkMode() {
      document.body.classList.toggle("dark");
      localStorage.setItem("darkMode", document.body.classList.contains("dark"));
    }

    function changeFont(font) {
      document.body.style.fontFamily = font;
      localStorage.setItem("selectedFont", font);
    }

    // Password check
    function checkPassword() {
      const pass = document.getElementById("sharedPassword").value.trim();
      if(pass === SHARED_PASSWORD) {
        document.getElementById("passwordSection").style.display = "none";
        document.getElementById("diarySection").style.display = "block";
        loadEntriesRealtime();
      } else {
        alert("Incorrect password!");
      }
    }

    // ImgBB upload function returns Promise of URL
    function uploadImageToImgBB(file) {
      const apiKey = "1466e5972116e365b26ad42b2679d379";
      const formData = new FormData();
      formData.append("image", file);
      return fetch(`https://api.imgbb.com/1/upload?key=${apiKey}`, {
        method: "POST",
        body: formData
      })
      .then(res => res.json())
      .then(data => {
        if(data.success) {
          return data.data.url;
        } else {
          throw new Error("Image upload failed");
        }
      });
    }

    // Add new entry to Firestore
    async function addEntry() {
      const text = document.getElementById("entryText").value.trim();
      const author = document.getElementById("entryAuthor").value.trim();
      const category = document.getElementById("entryCategory").value;
      const imageInput = document.getElementById("imageInput");

      if(!text && imageInput.files.length === 0) {
        alert("Please enter text or select an image");
        return;
      }
      if(!author || (author.toLowerCase() !== "dave" && author.toLowerCase() !== "jeah")) {
        alert("Please enter author as Dave or Jeah");
        return;
      }

      let imageUrl = null;
      if(imageInput.files.length > 0) {
        try {
          imageUrl = await uploadImageToImgBB(imageInput.files[0]);
        } catch(e) {
          alert("Image upload failed: " + e.message);
          return;
        }
      }

      const newEntry = {
        text,
        author: author.toLowerCase(),
        category,
        timestamp: firebase.firestore.FieldValue.serverTimestamp(),
        imageUrl,
        replies: []
      };

      await db.collection("entries").add(newEntry);

      // Reset inputs
      document.getElementById("entryText").value = "";
      document.getElementById("entryAuthor").value = "";
      document.getElementById("imageInput").value = "";
    }

    // Load entries realtime from Firestore with filters applied client-side
    let unsubscribe = null;

    function loadEntriesRealtime() {
      if(unsubscribe) unsubscribe();

      unsubscribe = db.collection("entries")
        .orderBy("timestamp", "desc")
        .onSnapshot(snapshot => {
          let entries = [];
          snapshot.forEach(doc => {
            let data = doc.data();
            data.id = doc.id;
            // Firestore timestamp to JS Date
            if(data.timestamp && data.timestamp.toDate) data.timestamp = data.timestamp.toDate().toISOString();
            else data.timestamp = new Date().toISOString();
            entries.push(data);
          });
          renderEntries(entries);
        });
    }

    // Escape HTML
    function escapeHTML(text) {
      const div = document.createElement("div");
      div.textContent = text;
      return div.innerHTML;
    }

    // Render entries with filters/sorting/search
    function renderEntries(entries) {
      const entriesDiv = document.getElementById("entries");
      const filterCategory = document.getElementById("filterCategory").value;
      const sortOrder = document.getElementById("sortOrder").value;
      const searchKeyword = document.getElementById("searchKeyword").value.toLowerCase();

      // Filter and search client-side
      let filtered = entries.filter(e => {
        const matchCategory = filterCategory === "All" || e.category === filterCategory;
        const matchSearch = e.text.toLowerCase().includes(searchKeyword) || (e.replies && e.replies.some(r => r.text.toLowerCase().includes(searchKeyword)));
        return matchCategory && matchSearch;
      });

      // Sort
      filtered.sort((a,b) => {
        if(sortOrder === "asc") return new Date(a.timestamp) - new Date(b.timestamp);
        else return new Date(b.timestamp) - new Date(a.timestamp);
      });

      entriesDiv.innerHTML = "";
      filtered.forEach(entry => {
        const entryDiv = document.createElement("div");
        entryDiv.className = "entry " + (entry.author === "jeah" ? "red" : "blue");

        let html = `<strong>${escapeHTML(entry.author.charAt(0).toUpperCase() + entry.author.slice(1))}</strong> <small>${new Date(entry.timestamp).toLocaleString()}</small><br/>`;

        html += `<em>${escapeHTML(entry.category)}</em><br/>`;

        if(entry.imageUrl) html += `<img src="${entry.imageUrl}" alt="Entry Image" />`;

        html += `<p>${escapeHTML(entry.text)}</p>`;

        // Edit & Delete buttons
        html += `<button onclick="startEditEntry('${entry.id}', '${escapeHTML(entry.text)}', '${escapeHTML(entry.author)}', '${escapeHTML(entry.category)}')">Edit</button> `;
        html += `<button onclick="deleteEntry('${entry.id}')">Delete</button>`;

        // Reply input box
        html += `
          <div style="margin-top:10px;">
            <input type="text" placeholder="Write a reply..." id="replyInput_${entry.id}" />
            <input type="text" placeholder="Your name (Dave or Jeah)" id="replyAuthor_${entry.id}" />
            <button onclick="addReply('${entry.id}')">Reply</button>
          </div>
        `;

        // Render replies
        if(entry.replies && entry.replies.length > 0) {
          entry.replies.sort((a,b) => new Date(a.timestamp) - new Date(b.timestamp));
          entry.replies.forEach((reply, idx) => {
            html += `
              <div class="reply">
                <strong>${escapeHTML(reply.author.charAt(0).toUpperCase() + reply.author.slice(1))}</strong>: ${escapeHTML(reply.text)}
                <small>${new Date(reply.timestamp).toLocaleString()}</small>
                <button class="delete-reply" title="Delete reply" onclick="deleteReply('${entry.id}', ${idx})">√ó</button>
              </div>
            `;
          });
        }

        entryDiv.innerHTML = html;
        entriesDiv.appendChild(entryDiv);
      });

      loadPhotoDump(entries);
    }

    // Edit entry
    let editingEntryId = null;
    function startEditEntry(id, text, author, category) {
      editingEntryId = id;
      document.getElementById("entryText").value = text;
      document.getElementById("entryAuthor").value = author;
      document.getElementById("entryCategory").value = category;
      window.scrollTo({top: 0, behavior: "smooth"});
    }

    async function saveEditEntry() {
      const text = document.getElementById("entryText").value.trim();
      const author = document.getElementById("entryAuthor").value.trim();
      const category = document.getElementById("entryCategory").value;
      if(!text) {
        alert("Entry text cannot be empty");
        return;
      }
      if(!author || (author.toLowerCase() !== "dave" && author.toLowerCase() !== "jeah")) {
        alert("Please enter author as Dave or Jeah");
        return;
      }
      await db.collection("entries").doc(editingEntryId).update({
        text,
        author: author.toLowerCase(),
        category
      });
      editingEntryId = null;
      document.getElementById("entryText").value = "";
      document.getElementById("entryAuthor").value = "";
      alert("Entry updated!");
    }

    // Add new reply
    async function addReply(entryId) {
      const input = document.getElementById(`replyInput_${entryId}`);
      const authorInput = document.getElementById(`replyAuthor_${entryId}`);
      const text = input.value.trim();
      const author = authorInput.value.trim();

      if(!text) {
        alert("Reply text cannot be empty");
        return;
      }
      if(!author || (author.toLowerCase() !== "dave" && author.toLowerCase() !== "jeah")) {
        alert("Please enter author as Dave or Jeah");
        return;
      }

      const entryRef = db.collection("entries").doc(entryId);

      // Get current replies array
      const doc = await entryRef.get();
      if(!doc.exists) {
        alert("Entry not found");
        return;
      }

      let replies = doc.data().replies || [];
      replies.push({
        text,
        author: author.toLowerCase(),
        timestamp: new Date().toISOString()
      });

      await entryRef.update({ replies });

      input.value = "";
      authorInput.value = "";
    }

    // Delete reply by index
    async function deleteReply(entryId, replyIndex) {
      const entryRef = db.collection("entries").doc(entryId);
      const doc = await entryRef.get();
      if(!doc.exists) {
        alert("Entry not found");
        return;
      }
      let replies = doc.data().replies || [];
      if(replyIndex >= 0 && replyIndex < replies.length) {
        replies.splice(replyIndex, 1);
        await entryRef.update({ replies });
      }
    }

    // Delete entry
    async function deleteEntry(id) {
      if(confirm("Are you sure you want to delete this entry?")) {
        await db.collection("entries").doc(id).delete();
      }
    }

    // Load photo dump from all images in entries
    function loadPhotoDump(entries) {
      const photoDump = document.getElementById("photoDump");
      photoDump.innerHTML = "";
      const images = entries
        .filter(e => e.imageUrl)
        .map(e => e.imageUrl);
      images.forEach(src => {
        const img = document.createElement("img");
        img.src = src;
        img.title = "Click to view full size";
        img.onclick = () => window.open(src, "_blank");
        photoDump.appendChild(img);
      });
    }

    // Mood notification via EmailJS
    function sendMood(mood) {
      const author = document.getElementById("entryAuthor").value.trim();
      if(!author || (author.toLowerCase() !== "dave" && author.toLowerCase() !== "jeah")) {
        alert("Please enter author as Dave or Jeah before sending mood");
        return;
      }

      const templateParams = {
        from_name: author,
        mood: mood,
        to_name: author.toLowerCase() === "dave" ? "Jeah" : "Dave",
        message: `${author} feels ${mood}!`
      };

      emailjs.send("service_g01f5f1", "template_vzvlohc", templateParams)
      .then(() => alert("Mood notification sent!"))
      .catch(err => alert("Failed to send mood notification: " + err));
    }

    // Hook addEntry button to support editing mode
    const postButton = document.querySelector("button[onclick='addEntry()']");
    postButton.addEventListener("click", async (e) => {
      e.preventDefault();
      if(editingEntryId) {
        await saveEditEntry();
        loadEntriesRealtime();
      } else {
        await addEntry();
      }
    });
  </script>
</body>
</html>
